# Что сделано/реализовано:
 - базовое ядро 
    - принцип работы на 10.10.25:
      - ввод команды -> публикация события -> обработка команды -> публикация события -> подхват скриптом -> работа скрипта -> публикация вывода сркипта -> вывод в консоль
      - **comand_line_input -> event_bus -> intent_processor -> event_bus -> time_check -> event_bus -> cli_output**
 - **EventBus** умеет: `subscribe`, `unsubscribe`, `publish`. стандартная комплектация для подобной вещи
 - "долгая память" в DatabaseManager (`aiosqlite`) - не общая
 - "опреативная память" в ContextManager. Управляет краткосрочной памятью (контекстом диалога) с использованием **Redis** и механизма **TTL**.
 - базовый **VirtualDevice(Protocol)**.
 - базовый **StateManager** для установки и получениея статуса оборудывания. умеет: `set_state(self, key: str, value: Any) -> None, get_state(self, key: str) -> Any`.
 - базовый **DeviceManager** для управления оборудыванием. умеет: `add_device(self, device: VirtualDevice) -> None, remove_device(self, device_id: str) -> None, get_device(self, device_id: str) -> VirtualDevice | None`.
 - базовый **LocationManager** для управления помещениями. умеет: `add_*, list_*, delete_*, get_* для location, flor, room, device. дополнительно:  get_all_devices_names, resolve_devices_by_room, get_user_location_by_voice_input`.
 - базовый **ActionDispatcher** для выполнение интентов по управлению устростойствами. умеет: `dispatch(self, intent: Intent) -> bool, _handle_device_power(self, data: Dict[str, Any]) -> bool`
 - базовый **IntentProcessor** для получения интентов и сущностей, обрабатывает как **"жесткое"** совпадение так и некоторые команды через NLP-модель.
 - подключена **NLP-модель** для расспознавания некоторых команд и сущностей
 - хелп по скиптам. заполнены только интернет и хелп
 - ввод/вывод через командную строку
 - базовый **Scheduler**. умеет: `run_later и cancel_task`.
 - базовый **ScriptRunner**. умеет: `load_scripts(self) -> None, _initialize_script(self, module: Any) -> None. использует: importlib.util`.
 - базовое выключение системы с прерыванием всех выполняемый задач, без graceful shutdown других подсистем.
 - загрузка из конфига применена, но она происходит напрямую при инициализации ядра
 - базовый логер. подписан в EventBus на `state_changed`, `loging_*`, `comand_line_input`
 - ConfigManager который загружает все переменные из **system_config.yaml**
 - базовый **HealthChecker**. умеет: `check_redis_connection(self) -> bool`
 - **logger_manager**. умеет писать в файл и писать в консоль. отдельно реализован хендлер ошибок `asyncio` и других выше `ERROR` с сохранением в отдельный лог
 - базовый **Watchdog** (`task_watcher.py`) который мониторит состояние (пока что "CMD_Input_Loop" и "Health_Monitor_Loop") и перезапускает службы.
 - замена базового **EventBus** на **redis_event_bus**. теперь все делаеться через очеред из базы **Redis** в **Docker** контейнере.
 - базовая долгая память в **PostgreSQL** в Docker контейнере.
 - менеджер секретов и внесен первый секрет
 - изменен подход в доступе к **Redis** базе. один менеджер подключения на два пользователя *ContextManager* и *RedisEventBus*
 - исправлена и настроена правильная остановка системы через `EXIT_SEQUENCE`. 
 - изменен порядок принцип работы на 22.10.25: 
       - ввод команды -> публикация события -> обработка команды -> публикация события -> подхват скриптом -> работа скрипта -> публикация вывода сркипта -> вывод в консоль
       - **comand_line_input -> redis_event_bus -> intent_processor -> redis_event_bus -> time_check -> redis_event_bus -> cli_output**
 - добавлен **SessionManager**, который следит за источником ввода
 - добален **NotificationManager** для вывода ответа ассистента в источник команды.
 - добавлен вывод на источник команды, например: *ввод тг -> вывод в тг*.
 - исправлены скрипты `time_check`, `help_script`, `internet_check` для правельного вывода. ВАЖНО следить за payload и всеми его полями.
 - добавлен базовый вывод/ввод через тг бот. на основе *Subota_AI* бота.
 - добавлен **API Gateway** (FastAPI) сервер с базовым авторизацией и выполнением команд
 - изменен запуск, теперь открытый поток асинхрона поддерживет uvicorn, запуск тоже через него.
 - создан планировщик задач (**SchedulerManager**) и пара скриптов: для создания задачи (`task_scheduler_script.py`) и для обработки наступившей задачи (`alarm_handler_script.py`). пока только для одноразовых задач.
 - создан базовый **NetworkController** и методы по проверке интернета, и доступа во внешний мир. дописать его по мере продвижения по проекту.
 - переписан старый (из *Subota 2.0*) код для получения погоды. 
 - подключен старый (из *Subota 2.0*) `num_to_text` для обработки цифр в ответах из интернета. (задел на будущее для подключения к голосовому выводу).
 - исправлено завершение тг-бота.
 - базовый **WebController** с маршрутами и зависимостями.
 - базовый веб-интерфес с 5-ю страницами: *index*, *login*, *network*, *scheduler*, *status*. сделан выход, базовая авторизация (пока со стандартными данными для входа).
 - добавлен голосовой ввод **VoiceController** и **VoskRecognizer**.
 - добавлен голосовой вывод **SileroTTSController** и **VoiceSender**. 
 - помошник полностью реагирует на голосовые команды. замечена не совсем правильное распознание, но возможно из за шума или разговоров вокруг меня.
 - написаны тесты: 
    - `core: test_health_checker.py, test_notification_manager.py`; 
    - `integration: test_api_auth.py, test_api_commands.py, test_command_cycle.py, test_dependencies.py, test_network.py, test_postgres_manager.py, test_redis_manager.py, test_scheduler.py, test_status.py, test_web_ui.py`; 
    - `scripts: test_alarm_handler_script.py, test_telegram_sender.py, test_voice_sender.py, test_web_ui_sender.py`; 
    - `unit: test_action_dispatcher.py, test_auth_manager.py, test_context_manager.py, test_device_manager.py, test_exit_sequence.py, test_intent_processor.py, test_location_manager.py, test_network_controller.py, test_redis_event_bus.py, test_script_runner.py, test_state_manager.py, test_task_watcher.py, test_telegram_input.py, test_unit_scheduler.py`
 - миграция с **Alembic** подключена.
 - сменен способ передачи аудион сигнала на распознание: теперь это проходит через веб-сокет и ответ идет в источник.
 - Изолированы сбои в **EventBus**: Теперь ошибки в отдельных обработчиках событий не приведут к падению всей шины.
 - Устойчивый запуск: Добавлена логика повторных попыток для инициализации **Redis**, **PostgreSQL** и выполнения миграций, что делает запуск приложения более надежным при временной недоступности баз данных.
 - Мониторинг веб-сервера: Веб-сервер Uvicorn теперь контролируется **TaskWatcher** и будет автоматически перезапускаться в случае сбоев, предотвращая частичные отказы системы.
 - Улучшено завершение работы: Обработка ошибок при остановке **WebController** в `Core.stop()` стала более надежной.
 - Исправлен скрипт погоды: Скрипт weather.py теперь корректно взаимодействует с **NetworkController** и правильно обрабатывает сетевые ошибки.
 - `core/metrics_collector.py`:
       * Реализован сбор метрик: Этот модуль полностью реализует сбор различных метрик:
           * Системные метрики: Загрузка CPU (`cpu_load`) и использование оперативной памяти (`ram_usage`) с помощью библиотеки `psutil`.
           * Метрики состояния сервисов: Статус и задержка подключения к *Redis* (`redis_status`, `redis_latency_ms`) и *PostgreSQL* (`postgres_status`,       
             `postgres_latency_ms`), используя *HealthChecker*.
           * Метрики статуса модулей: Собирает статусы мониторируемых задач из *TaskWatcher* (например, `module_status_CMD_Input_Loop`).
       * Интеграция с базой данных: Сохраняет все собранные метрики в таблицу `system_metrics` в *PostgreSQL* через *PostgresManager*. Метрики записываются с именем, значением (как `float` или `string`) и источником.
       * Автоматический цикл сбора: Включает асинхронный цикл (_metrics_collection_loop), который периодически собирает и сохраняет все метрики с    
         заданным интервалом.
       * Управление жизненным циклом: Предоставляет методы `start()` и `stop()` для корректного запуска и остановки цикла сбора метрик, включая обработку `asyncio.CancelledError`.
 - `alembic/versions/8891696241f6_add_system_metrics.py`:
       * Миграция базы данных: Создана новая миграция *Alembic*, которая добавляет в *PostgreSQL* таблицу с именем `system_metrics`.
       * Структура таблицы: Таблица `system_metrics` определена со следующими колонками: *id (SERIAL PRIMARY KEY), timestamp (TIMESTAMP WITH TIME ZONE  
         DEFAULT CURRENT_TIMESTAMP NOT NULL), metric_name (TEXT NOT NULL), metric_value_float (DOUBLE PRECISION), metric_value_string (TEXT) и      
         source (TEXT)*.
       * Индексы: Добавлены индексы `idx_metrics_timestamp` и `idx_metrics_name_ts` для ускорения выборки данных по времени и имени метрики.
 -  `core/core_init.py`:
       * Инициализация: Модуль **MetricsCollector** инициализируется в методе `__init__` класса Core (на этапе "FOURTH STAGE").
       * Запуск/Остановка: **MetricsCollector** корректно запускается (`await self.metrics_collector.start()`) в методе `start()` класса *Core* (на этапе
         "FOURTH STAGE") и останавливается (`await self.metrics_collector.stop()`) в методе `stop()` класса *Core* (на этапе "FIRST STAGE" завершения
         работы системы). Это обеспечивает непрерывный сбор метрик в течение всего времени работы приложения и их корректное сохранение при    
         завершении.
 - Добавлена метрика энергопотребления системы:
       * В `core/metrics_collector.py` добавлена синхронная функция `_get_power_consumption_watts()`, которая считывает текущее энергопотребление ноутбука из `/sys/class/power_supply/` (в
         Ваттах).
       * Эта метрика `power_consumption_watts` собирается и сохраняется в базу данных *PostgreSQL* модулем *MetricsCollector*, но только когда ноутбук работает от батареи.
       * На веб-странице `/web/templates/status.html` добавлено отображение этой метрики.
 - Реализовано автоматическое определение внешнего *IP-адреса*:
       * В `config/system_config.yaml` поле `external_ip` было очищено, чтобы сигнализировать о необходимости автоматического определения.
       * В `core/network_controller.py` добавлен асинхронный метод `initialize()`, который вызывает `get_external_ip()` при старте, если `external_ip` не задан в конфиге.
       * В `core/core_init.py` добавлен вызов `network_controller.initialize()` в процедуре запуска ядра.
       * Исправлена ошибка `Cannot assign requested address` при пинге: Модифицирована логика *check_ping* в `core/network_controller.py` таким образом, что для внешних хостов (8.8.8.8)
         исходный IP-адрес не указывается, позволяя операционной системе самой выбирать исходящий интерфейс.
 - реализован Универсальный центр уведомлений. вывод событий в веб-интерфейсе в отдельном поле вывода через **WebUISender** и `web-socket`
 - в `core/rbac_manager.py` есть строка:
   ```python
   await self.core.notification_manager.publish_notification(
   text=f"Пользователь с идентификатором '{identifier}' не найден. Используется роль по умолчанию: 'guest'.", 
   ugrgency='warning', 
   destinations=['web_ui']
                                                            )
   ```
   так выводятся сооющения в *WebUI* в веб-интерфейсе
 - добавлен правильный пользователь и правильно прописана авторизация
 - добавлен **SystemLogProcessor** для сохранения логов `WARN` и выше в бд и для доступа к истории.
 - Улучшен пользовательский интерфейс благодаря интеграции **Bootstrap** и **Font Awesome** с несколькими шаблонами.
 - Обновлены шаблоны входа в систему, сети, планировщика и статуса с использованием **Bootstrap** для улучшения стиля и адаптивности.
 - Добавлены значки *Font Awesome* для лучшего визуального представления.
 - Переработана структура *HTML* для использования компонентов **Bootstrap**, таких как карточки и таблицы.
 - Добавлены новые нижний колонтитул и панель навигации для единообразной навигации и брендинга.
 - Реализован **JavaScript** для динамического управления историей журнала с помощью пагинации.
 - доделан "Универсальный центр уведомлений." 
   - **ASSISTANT_RESPONSE** и системные уведомления отображаются в реальном времени на всех страницах веб-интерфейса. История сохраняется в `localStorage`. CLI по-прежнему получает сообщения.
   - **WebSocket**-соединения используются как для чата, так и для универсальной ленты уведомлений, обеспечивая обновления в реальном времени.
   - **История системных логов** (`log_history.html`) поддерживает фильтрацию и пагинацию. Лента уведомлений сохраняет историю через `localStorage`.
 - созданы скрипты **backup.sh restore.sh** и **rotate_backups.sh**. добавлен `backup_scheduler` для отслеживания и создания копий. Тесты написаны. Способ востановления в заметках
 - версионирование скриптов. переписан **ScripRunner** под новую иерархию версинирования
 - "сухой запуск": в конфиге просто изменить **dry_run** на `True`. Важно: после отладки изменить **dry_run** на `False`, поскольку скрипты работать не будут.
 - менеджер определения устройств **DiscoveryManager** по `UPnP / mDNS`. по состоянию на 16.12.2025 DiscoveryManager смог найти один не рабочий роутер, один рабочий. Тестируемое оборудование *MikroTik SXTsq 5* (версия прошивки 6.49.18, это та на которую я смог его прошить). файл настроек роутера `subota_config.rsc`
 - базовый класс с безопастностью **SubotaService**: базовый слой, который гарантирует, что любое сообщение, пришедшее в сервис, является подлинным (отправлено тем, кем заявлено), целостным (не менялось по пути) и актуальным (не является повтором старой команды). Как это работает:
   - HMAC-Авторизация (Кто отправил?):
      - Каждый пакет подписывается уникальным ключом сервиса.
      - При получении декоратор `@secure_event` пересчитывает подпись. Если хотя бы один символ в данных (включая вложенный `content`) изменен — сервис отвергает пакет.
   - Защита от Replay-атак (Это не старая запись?):
      - Используется механизм Nonce (одноразовый номер). Каждый пакет получает уникальный UUID.
      - Сервис хранит историю последних `Nonce` в `TTLCache`. Если злоумышленник перехватит валидный пакет и отправит его снова, система увидит дубликат и заблокирует его.
   - Валидация времени (`Clock Skew`):
      - Пакет содержит `timestamp`. Если разница между временем создания и временем получения слишком велика (например, >10 сек), пакет считается просроченным. Это сужает «окно возможностей» для атак.
   - Адаптивная защита и `Alarm` (Что если нас атакуют?):
      - `Rate Limiting`: Ограничивает количество запросов от конкретного пользователя в секунду.
      - `Forensics & Alarm`: Если сервис фиксирует серию ошибок безопасности (неверная подпись, старый `nonce`), он не просто молчит, а:
         - Заносит данные в `sec_forensics` лог для анализа.
         - Переходит в `Alarm Mode`, оповещая систему через `emergency_queue`.
         - Включает «кулдаун» (защиту от спама самих уведомлений о тревоге).
   - Памятка по использованию:
      - Для отправки: Используй `create_base_payload()` → заполни `content` → подпиши через `sign_payload()`.
      - Для приема: Просто оберни метод-обработчик в `@secure_event`. Если выполнение зашло внутрь метода — значит, за дверью «свой» и данные чисты.
      - Важно: Все бизнес-данные всегда клади в `payload["data"]["content"]`, иначе они не попадут под защиту HMAC.
   - заложен простейший `TUI`, введена переменная "use_tui_mode" для переключения режимо
 - смена парадигмы **SubotaService**: добавлена функиция: 
 ```python
 async def publish_to_event_bus(instance: 'SubotaService', 
                                   answer_type: str, 
                                   payload: Optional[dict] = None, 
                                   text: Optional[str] = None, 
                                   content: Optional[dict] = None
                                   )
```
которая сама отправляет и подписывает сообщения, что сократило число посвторяющихся строк кода. на 19.01.25 `payload` временный, после будет обязательный.
- 19.01.26:
  - добавлены *API*: статический `SubotaInterface` и динамический `ModuleInterface` для рефакторинга инициализации *Core*. и отдельный *API* для скриптов `ScriptAPI`.
  - Вынесен в отдельный модуль менеджер соединений *WebSocketConnectionManager*
  - проведен рефакторинг 40% ядра с вклбчением безопастности и ввдением API
